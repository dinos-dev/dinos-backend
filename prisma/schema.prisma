datasource db {
  provider = "postgresql"
  url      = env("DB_URL")
}

generator client {
  provider = "prisma-client-js"
}

// 유저 정보
model User {
  id          Int          @id @default(autoincrement())

  email       String       @unique @db.VarChar(255)
  name        String?      @db.VarChar(45)
  password    String?      @db.VarChar(255)
  isActive    Boolean      @default(true) @map("is_active")
  provider    Provider     @default(LOCAL)
  providerId  String?      @unique @db.VarChar(255) @map("provider_id")

  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")
  deletedAt   DateTime?    @map("deleted_at")
  version     Int          @default(0)

  //? 1:1 
  profile     Profile?
  inviteCode InviteCode? 
  
  //? 1:N
  tokens                 Token[]            @relation("UserToken")
  sentFriendRequests     FriendRequest[]    @relation("RequestSender")    
  receivedFriendRequests FriendRequest[]    @relation("RequestReceiver")  
  friendshipsAsRequester Friendship[]       @relation("FriendshipRequester") 
  friendshipsAsAddressee Friendship[]       @relation("FriendshipAddressee") 
  bookmarks              Bookmark[]         @relation("UserBookmark")
  pins                   Pin[]              @relation("UserPin")
  reviews                Review[]           @relation("UserReview")

  @@map("users")
}

// 친구 요청 테이블
model FriendRequest {
  id           Int                    @id @default(autoincrement())
  senderId     Int                    @map("sender_id")    // 요청을 보낸 사용자 ID
  receiverId   Int                    @map("receiver_id")  // 요청을 받은 사용자 ID

  status       FriendRequestStatus    @default(PENDING)
  respondedAt  DateTime?              @map("responded_at") // 응답한 시간
  expiresAt    DateTime?              @map("expires_at")   // 요청 만료 시간
  
  createdAt    DateTime               @default(now()) @map("created_at")
  updatedAt    DateTime               @updatedAt @map("updated_at")
  version      Int                    @default(0)

  //?? Relations
  sender       User                   @relation("RequestSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver     User                   @relation("RequestReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  //? constraint: 같은 사용자 간에는 하나의 pending 요청만 존재
  @@unique([senderId, receiverId], map: "unique_sender_receiver")
  @@index([receiverId, status], map: "idx_receiver_status") 
  @@index([senderId, status], map: "idx_sender_status")    

  @@map("friend_requests")
}

// 친구 관계 테이블 (승인된 친구 관계)
model Friendship {
  id           Int      @id @default(autoincrement())
  requesterId  Int      @map("requester_id")  // 친구 요청을 먼저 보낸 사용자
  addresseeId  Int      @map("addressee_id")  // 친구 요청을 받은 사용자
  
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  version      Int      @default(0)

  //? N:1
  
  // 친구 요청을 먼저 보낸 사람
  requester    User     @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  // 친구 요청을 받고 승인한 사람
  addressee    User     @relation("FriendshipAddressee", fields: [addresseeId], references: [id], onDelete: Cascade)
  // 친구와 활동 기록 정보
  activities   FriendshipActivity[]

  // 제약 조건: 중복 친구 관계 방지
  @@unique([requesterId, addresseeId], map: "unique_requester_addressee")
  @@index([requesterId], map: "idx_requester_id")
  @@index([addresseeId], map: "idx_addressee_id")

  @@map("friendships")
}


// 유저의 프로필 정보 
model Profile {
  id          Int       @id @default(autoincrement())
  userId      Int       @unique @map("user_id")

  nickname    String    @db.VarChar(20) @map("nickname")
  comment     String?   @db.VarChar(50)
  headerId    Int?      @map("header_id")
  bodyId      Int?      @map("body_id")
  headerColor String?   @db.VarChar(8) @map("header_color")
  bodyColor   String?   @db.VarChar(8) @map("body_color")

  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  version     Int       @default(0)

  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}


// user의 auth 토큰 정보 
model Token {
  id         Int           @id @default(autoincrement())
  userId     Int           @map("user_id")

  refToken   String        @db.VarChar(255) @map("ref_token")
  expiresAt  DateTime      @map("expires_at")
  platform   PlatformEnumType

  createdAt  DateTime      @default(now()) @map("created_at")
  updatedAt  DateTime      @updatedAt @map("updated_at")
  version    Int           @default(0)

  //? N:1
  user       User          @relation("UserToken", fields: [userId], references: [id], onDelete: Cascade)

  @@index([refToken])

  @@map("tokens")
}

// user의 친구 초대 코드
model InviteCode {
  id        Int      @id @default(autoincrement())
  userId    Int      @unique @map("user_id")

  code      String   @unique @db.VarChar(11) 

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  //? 1:1
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("invite_codes")
}

//? 친구 관계 활동 정보 (확장성을 고려하여 아래와 같이 설계)
model FriendshipActivity {
  id           Int          @id @default(autoincrement())
  friendshipId Int          @map("friendship_id")
  
  activityType ActivityType @default(MEAL_TOGETHER) @map("activity_type")
  activityDate DateTime     @default(now()) @map("activity_date")
  
  // 확장성 고려한 필드 ( 추후 추가 가능 )
  location     String?      @db.VarChar(150)  // 장소
  
  createdAt    DateTime     @default(now()) @map("created_at")
  updatedAt    DateTime     @updatedAt @map("updated_at")
  version      Int          @default(0)

  //? N:1
  friendship   Friendship   @relation(fields: [friendshipId], references: [id], onDelete: Cascade)

  @@index([friendshipId, activityType], map: "idx_friendship_activity_type")
  @@index([activityDate], map: "idx_activity_date")

  @@map("friendship_activities")
}

//? bookmarks ( feeds 정보 marking용 )
model Bookmark {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")

  itemType  ItemType @map("item_type") 

  //? reference mongo document id (mongo object id fix 24 characters)
  feedRefId         String  @db.VarChar(24)  @map("feed_ref_id")
  restaurantRefId   String  @db.VarChar(24)  @map("restaurant_ref_id")

  // restaurant or feed name
  itemName String  @db.VarChar(50) @map("item_name")  
  // restaurant or feed image url 
  itemImageUrl String? @db.VarChar(500) @map("item_image_url")
  // FEED -> editor name | RESTAURANT -> summary restaurant
  itemSub String @db.VarChar(50) @map("item_sub")
  
  createdAt  DateTime      @default(now())  @map("created_at")
  updatedAt  DateTime      @updatedAt       @map("updated_at") 

  //? N:1
  user       User          @relation("UserBookmark", fields: [userId], references: [id])

  @@unique([userId, feedRefId, restaurantRefId], name: "unique_user_bookmark")
  @@index([userId, itemType], name: "idx_user_type_bookmarks")
  @@index([userId, createdAt(sort: Desc)], name: "idx_user_created_at_desc")

  @@map("bookmarks")
}

//? 가게 정보 테이블
model Restaurant {
  id        Int         @id @default(autoincrement())
  name      String      @db.VarChar(100) @map("name")
  /// 가게 ID (Prefix_UNIQUE_ID)
  // refPlaceId String   @db.VarChar(50) @map("ref_place_id") @unique

  address   String   @db.VarChar(200) @map("address")

  /// 가게의 위도 & 경도 
  latitude  Float    @map("latitude")
  longitude Float    @map("longitude")


  /// 가게의 마지막 동기화 시간  
  lastSyncedAt DateTime @map("last_synced_at") 
  /// 가게의 활성 상태
  isActive Boolean @default(true) @map("is_active")
  /// 가게의 카테고리
  category String? @db.VarChar(100) @map("category")

  /// 가게 대표 이미지 URL (최초 리뷰어의 대표 이미지를 채택)
  primaryImageUrl  String?  @db.VarChar(500) @map("primary_image_url")
  /// 대표 이미지 설정자 추적 (관리자 교체 시 null, 리뷰 삭제 시 처리용)
  primaryImageSetBy Int?    @map("primary_image_set_by")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  //? 1:N 
  pins Pin[]  @relation("RestaurantPin")
  reviews Review[] @relation("RestaurantReview")
  
  @@unique([name, address], name: "unique_name_address")

  @@index([latitude, longitude], map: "idx_latitude_longitude")
  @@index([category], map: "idx_category")

  @@map("restaurants")
}

//? 핀 테이블 ( 사용자가 가고 싶은 가게에 대한 pins )
model Pin {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  restaurantId Int      @map("restaurant_id")

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  //? N:1
  user         User       @relation("UserPin", fields: [userId], references: [id], onDelete: Cascade)
  restaurant   Restaurant @relation("RestaurantPin", fields: [restaurantId], references: [id], onDelete: Cascade)

  //? 사용자당 음식점 하나만 핀 가능
  @@unique([userId, restaurantId], map: "unique_user_restaurant_pin")
  
  @@map("pins")
}

//? 리뷰 테이블 (실제 방문 데이터 및 후기 ) 
model Review {
  id           Int      @id @default(autoincrement())
  userId       Int      @map("user_id")
  restaurantId Int      @map("restaurant_id")
  
  content      String?  @db.VarChar(500) // 내가 방문한 가게에 대한 공통 리뷰 ( 서술형 )
  wantRecommendation  Boolean   @default(false) @map("want_recommendation")
  
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // 리뷰 데이터를 지울지는 아직 미확정 
  version             Int       @default(0)

  //? N:1
  user         User       @relation("UserReview", fields: [userId], references: [id], onDelete: Cascade)
  restaurant   Restaurant @relation("RestaurantReview", fields: [restaurantId], references: [id], onDelete: Cascade)

  //? 1:N
  answers             ReviewAnswer[]
  images              ReviewImage[]

  @@index([userId, restaurantId], map: "idx_user_restaurant_reviews")
  @@index([restaurantId], map: "idx_restaurant_reviews")
  @@index([wantRecommendation], map: "idx_want_recommendation")

  @@map("reviews")
}


model ReviewImage {
  id        Int      @id @default(autoincrement())
  reviewId  Int      @map("review_id")
  imageUrl  String   @db.VarChar(500) @map("image_url")
  isPrimary Boolean  @default(false) @map("is_primary")
  sortOrder Int      @default(0) @map("sort_order")

  createdAt DateTime @default(now()) @map("created_at")

  //? N:1
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@index([reviewId, isPrimary], map: "idx_review_image_primary")
  @@map("review_images")
}

model ReviewQuestion {
  id        Int         @id @default(autoincrement())
  step      ReviewStep
  content   String      @db.VarChar(500)
  isActive  Boolean     @default(true) @map("is_active")
  sortOrder Int         @default(0) @map("sort_order")

  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime    @updatedAt @map("updated_at")

  //? 1:N
  options   ReviewQuestionOption[]
  answers   ReviewAnswer[]

  @@index([step, isActive], map: "idx_question_step_active")
  @@map("review_questions")
}

model ReviewQuestionOption {
  id           Int      @id @default(autoincrement())
  questionId   Int      @map("question_id")
  content      String   @db.VarChar(200)
  userTagLabel String   @db.VarChar(100) @map("user_tag_label")
  sortOrder    Int      @default(0) @map("sort_order")
  isActive     Boolean  @default(true) @map("is_active")

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  //? N:1
  question     ReviewQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  //? 1:N
  answers      ReviewAnswer[]

  @@index([questionId], map: "idx_option_question")
  @@map("review_question_options")
}

model ReviewAnswer {
  id            Int      @id @default(autoincrement())
  reviewId      Int      @map("review_id")
  questionId    Int      @map("question_id")
  optionId      Int?     @map("option_id")
  customAnswer  String?  @db.VarChar(300) @map("custom_answer")

  createdAt     DateTime @default(now()) @map("created_at")

  //? N:1
  review        Review                @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  question      ReviewQuestion        @relation(fields: [questionId], references: [id], onDelete: Cascade)
  option        ReviewQuestionOption?  @relation(fields: [optionId], references: [id], onDelete: SetNull)

  @@unique([reviewId, questionId], map: "unique_review_question")
  @@index([reviewId], map: "idx_answer_review")
  @@index([optionId], map: "idx_answer_option")
  @@map("review_answers")
}

enum Provider {
  LOCAL
  GOOGLE
  APPLE
  NAVER
  KAKAO
}

enum PlatformEnumType {
  WEB
  IOS
  ANDROID
  UNKNOWN
}

/* 친구 요청 상태 enum
  @param PENDING 대기중
  @param ACCEPTED 승인됨
  @param REJECTED 거절됨
  @param CANCELLED 취소됨 (보낸 사람이 취소)
  @param EXPIRED 만료됨
*/
enum FriendRequestStatus {
  PENDING   
  ACCEPTED  
  REJECTED  
  CANCELLED 
  EXPIRED   
}

/**
 * 친구와 활동 유형 ( 확장성을 고려하여 아래와 같이 ENUM으로 지정 )
 * @param MEAL_TOGETHER ( 함께 식사 )
 * @param OTHER ( 기타 )
 */
enum ActivityType {
  MEAL_TOGETHER 
}

//? bookmarks item type 
enum ItemType {
  FEED
  RESTAURANT
}

/**
 * 리뷰 단계 enum
 * @param BEFORE_ENTRY 입장전
 * @param ENTRY 입장
 * @param ORDER 주문
 * @param MEAL 식사
 * @param WRAP_UP 마무리
 */
enum ReviewStep {
  BEFORE_ENTRY
  ENTRY
  ORDER
  MEAL
  WRAP_UP
}

// // 핀의 타입 enum (방문 예정 vs 방문 완료)
// enum PinType {
//   PLANNED // 방문 예정 
//   VISITED // 방문 완료 
// }